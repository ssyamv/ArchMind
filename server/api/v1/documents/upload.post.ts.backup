/**
 * 文档上传 API 端点
 * 处理文件上传、内容提取、向量化
 */

import { promises as fs } from 'fs'
import { readFileSync } from 'fs'
import { extname, join } from 'path'
import { nanoid } from 'nanoid'
import YAML from 'js-yaml'
import { DocumentDAO } from '~/lib/db/dao/document-dao'
import { DocumentProcessingPipeline } from '~/lib/rag/pipeline'
import { EmbeddingServiceFactory } from '~/lib/rag/embedding-adapter'
import { getModelManager } from '~/lib/ai/manager'
import type { Document } from '~/types/document'

// 文件类型映射
const FILE_TYPE_MAPPING: Record<string, string> = {
  '.pdf': 'pdf',
  '.docx': 'docx',
  '.md': 'markdown',
  '.markdown': 'markdown'
}

// 最大文件大小：10MB
const MAX_FILE_SIZE = 10 * 1024 * 1024

// 上传目录
const UPLOAD_DIR = 'public/uploads'

/**
 * 提取 PDF 内容
 */
async function extractPdfContent (filePath: string): Promise<string> {
  const pdfParse = (await import('pdf-parse')).default
  const fileContent = await fs.readFile(filePath)

  const pdfData = await pdfParse(fileContent)
  return pdfData.text || ''
}

/**
 * 提取 DOCX 内容
 */
async function extractDocxContent (filePath: string): Promise<string> {
  const mammoth = (await import('mammoth')).default
  const fileBuffer = await fs.readFile(filePath)

  const result = await mammoth.extractRawText({ buffer: fileBuffer })
  return result.value || ''
}

/**
 * 提取 Markdown 内容
 */
async function extractMarkdownContent (filePath: string): Promise<string> {
  return fs.readFile(filePath, 'utf-8')
}

/**
 * 根据文件类型提取内容
 */
async function extractContent (filePath: string, fileType: string): Promise<string> {
  if (fileType === 'pdf') {
    return extractPdfContent(filePath)
  } else if (fileType === 'docx') {
    return extractDocxContent(filePath)
  } else if (fileType === 'markdown') {
    return extractMarkdownContent(filePath)
  }

  throw new Error(`Unsupported file type: ${fileType}`)
}

export default defineEventHandler(async (event) => {
  try {
    const formData = await readMultipartFormData(event)

    if (!formData || formData.length === 0) {
      throw new Error('No file provided')
    }

    const fileData = formData.find(item => item.name === 'file')
    if (!fileData) {
      throw new Error('File field not found')
    }

    if (!fileData.filename) {
      throw new Error('Filename is required')
    }

    const fileName = fileData.filename
    const ext = extname(fileName).toLowerCase()
    const fileType = FILE_TYPE_MAPPING[ext]

    if (!fileType) {
      throw new Error(`Unsupported file type: ${ext}. Supported types: .pdf, .docx, .md, .markdown`)
    }

    if (fileData.data.length > MAX_FILE_SIZE) {
      throw new Error(`File size exceeds maximum limit of ${MAX_FILE_SIZE / 1024 / 1024}MB`)
    }

    // 生成唯一的文件名
    const uniqueFileName = `${nanoid()}_${fileName}`
    const uploadPath = join(process.cwd(), UPLOAD_DIR)

    // 确保上传目录存在
    try {
      await fs.mkdir(uploadPath, { recursive: true })
    } catch (err) {
      console.error('Failed to create upload directory:', err)
    }

    const filePath = join(uploadPath, uniqueFileName)

    // 保存文件到磁盘
    await fs.writeFile(filePath, fileData.data)
    console.log(`File saved to ${filePath}`)

    // 提取文档内容
    let content = ''
    try {
      content = await extractContent(filePath, fileType)
    } catch (error) {
      console.error('Failed to extract content:', error)
      // 继续进行，即使提取内容失败
    }

    // 创建文档记录
    const doc: Omit<Document, 'id' | 'createdAt' | 'updatedAt'> = {
      userId: undefined,
      title: fileName.replace(ext, ''),
      filePath: join('uploads', uniqueFileName).replace(/\\/g, '/'),
      fileType: fileType as 'pdf' | 'docx' | 'markdown',
      fileSize: fileData.data.length,
      content,
      metadata: {
        originalFileName: fileName,
        uploadedAt: new Date().toISOString()
      },
      status: 'uploaded'
    }

    const createdDoc = await DocumentDAO.create(doc)
    console.log(`Document record created: ${createdDoc.id}`)

    // 异步处理向量化（不阻塞响应）
    if (content) {
      try {
        const runtimeConfig = useRuntimeConfig()
        const glmApiKey = runtimeConfig.glmApiKey as string | undefined
        const openaiApiKey = runtimeConfig.openaiApiKey as string | undefined
        
        // 获取当前选择的模型
        const config = {
          anthropicApiKey: runtimeConfig.anthropicApiKey,
          openaiApiKey: runtimeConfig.openaiApiKey,
          googleApiKey: runtimeConfig.googleApiKey,
          glmApiKey: runtimeConfig.glmApiKey,
          dashscopeApiKey: runtimeConfig.dashscopeApiKey,
          baiduApiKey: runtimeConfig.baiduApiKey,
          deepseekApiKey: runtimeConfig.deepseekApiKey,
          ollamaBaseUrl: runtimeConfig.ollamaBaseUrl
        }
        const modelManager = getModelManager(config)
        const defaultModelId = modelManager.getDefaultModelId()
        
        // 读取模型配置
        const configPath = join(process.cwd(), 'config', 'ai-models.yaml')
        const configContent = readFileSync(configPath, 'utf-8')
        const parsed = YAML.load(configContent) as { ai_models: { models: Record<string, any> } }
        const modelConfig = parsed.ai_models.models[defaultModelId]
        
        if (!modelConfig) {
          console.warn(`未找到模型 ${defaultModelId} 的配置，文档将不会被向量化`)
          return
        }
        
        // 根据默认模型创建对应的 Embedding 适配器
        const embeddingAdapter = await EmbeddingServiceFactory.createFromModelConfig(
          modelConfig,
          { glmApiKey, openaiApiKey }
        )
        
        if (embeddingAdapter) {
          const modelInfo = embeddingAdapter.getModelInfo()
          console.log(`使用 ${modelInfo.provider} Embedding 服务处理文档: ${modelInfo.modelId}`)
          
          const pipeline = new DocumentProcessingPipeline({ embeddingAdapter })
          pipeline.process(createdDoc.id, content).catch((error) => {
            console.error('文档处理管道失败:', error)
          })
        } else {
          console.warn(`模型 ${defaultModelId} 不支持 Embedding，文档将不会被向量化`)
        }
      } catch (error) {
        console.error('启动文档处理管道失败:', error)
      }
    }

    setResponseStatus(event, 201)
    return {
      success: true,
      data: createdDoc,
      message: 'Document uploaded successfully'
    }
  } catch (error) {
    console.error('Upload error:', error)
    setResponseStatus(event, 400)
    return {
      success: false,
      message: error instanceof Error ? error.message : 'Unknown error occurred',
      code: 'UPLOAD_FAILED'
    }
  }
})


